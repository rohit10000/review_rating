// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __rest } from "tslib";
import { createPipelineFromOptions, signingPolicy, isTokenCredential, bearerTokenAuthenticationPolicy, operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { SDK_VERSION } from "./constants";
import { GeneratedClient } from "./generated/generatedClient";
import { logger } from "./logger";
import { makeDetectLanguageResultCollection } from "./detectLanguageResultCollection";
import { makeRecognizeCategorizedEntitiesResultCollection } from "./recognizeCategorizedEntitiesResultCollection";
import { makeRecognizePiiEntitiesResultCollection } from "./recognizePiiEntitiesResultCollection";
import { makeAnalyzeSentimentResultCollection } from "./analyzeSentimentResultCollection";
import { makeExtractKeyPhrasesResultCollection } from "./extractKeyPhrasesResultCollection";
import { makeRecognizeLinkedEntitiesResultCollection } from "./recognizeLinkedEntitiesResultCollection";
import { createSpan } from "./tracing";
import { CanonicalCode } from "@opentelemetry/types";
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
/**
 * Client class for interacting with Azure Text Analytics.
 */
export class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, TextAnalyticsApiKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new TextAnalyticsApiKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl The URL to the TextAnalytics endpoint
     * @param {TokenCredential | TextAnalyticsApiKeyCredential} credential Used to authenticate requests to the service.
     * @param {TextAnalyticsClientOptions} [options] Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = __rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : signingPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(credential, this.endpointUrl, pipeline);
    }
    detectLanguage(inputs, countryHintOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const countryHint = countryHintOrOptions || this.defaultCountryHint;
                realInputs = convertToDetectLanguageInput(inputs, countryHint);
                realOptions = options || {};
            }
            else {
                // Replace "none" hints with ""
                realInputs = inputs.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
                realOptions = countryHintOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", realOptions);
            try {
                const result = yield this.client.languages({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeDetectLanguageResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeEntities(inputs, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionGeneral({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeCategorizedEntitiesResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    analyzeSentiment(inputs, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", realOptions);
            try {
                const result = yield this.client.sentiment({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeAnalyzeSentimentResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    extractKeyPhrases(inputs, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", realOptions);
            try {
                const result = yield this.client.keyPhrases({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeExtractKeyPhrasesResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizePiiEntities(inputs, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", realOptions);
            try {
                const result = yield this.client.entitiesRecognitionPii({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizePiiEntitiesResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    recognizeLinkedEntities(inputs, languageOrOptions, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let realOptions;
            let realInputs;
            if (isStringArray(inputs)) {
                const language = languageOrOptions || this.defaultLanguage;
                realInputs = convertToTextDocumentInput(inputs, language);
                realOptions = options || {};
            }
            else {
                realInputs = inputs;
                realOptions = languageOrOptions || {};
            }
            const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", realOptions);
            try {
                const result = yield this.client.entitiesLinking({
                    documents: realInputs
                }, operationOptionsToRequestOptionsBase(finalOptions));
                return makeRecognizeLinkedEntitiesResultCollection(realInputs, result.documents, result.errors, result.modelVersion, result.statistics);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
function isStringArray(inputs) {
    return typeof inputs[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}
//# sourceMappingURL=textAnalyticsClient.js.map